ifdef::env-github[:outfilesuffix: .adoc]

13/Simple Process Manager Interface v1
======================================

The MPI process manager interface (PMI) version 1 is a de-facto standard
API and wire protocol for communication between MPI runtimes and resource
managers.  It was added to the MPICH2 MPI-2 reference implementation in
late 2001, and has since been widely implemented, but was not officially
standardized by the MPI Forum and has been only lightly documented.
This RFC is an attempt to document PMI-1 to guide developers of resource
managers that must support current and legacy MPI implementations.

* Name: github.com/flux-framework/rfc/spec_13.adoc
* Editor: Jim Garlick <garlick@llnl.gov>
* State: raw

== Language

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to
be interpreted as described in http://tools.ietf.org/html/rfc2119[RFC 2119].

== Related Standards

* link:spec_12{outfilesuffix}[12/Flux Security Architecture]

== Goals

* Decrease coupling between process managers and MPI implementations by
clarifying their "contract" for communication.
* Document the PMI-1 application programming interface (API)
* Document the PMI-1 wire protocol
* Identify what changed between PMI 1.0 and 1.1
* Decrease the amount of research required to implement a process manager.
* Document MPI PMI implementation quirks that should be dealt with by process
managers seeking a wide range of compatibility
* Identify which functions are optional, and under what circumstances.

== PMI Versions

The main changes between PMI 1.0 and PMI 1.1 are in the wire protocol
and allowing local process group information to be communicated from
process manager to program via the key-value store.

PMI version 2 is a separate API and protocol and is not covered here.

PMIx ("x" for exascale, from the OpenMPI community) and PMIX extensions
to PMI-2 ("X" for extension, from the MVAPICH community) are also not
covered.

== Overview

PMI was designed as an interface between process managers and parallel
programs, including, but not limited to, MPI runtimes.  It has two main
parts, one part designed to assist with bootstrap activities that need
to take place inside 'MPI_Init()', and the other part designed to
support MPI-2's dynamic process management features, such as
'MPI_Comm_spawn()'.

A newly-launched MPI process needs to find out (minimally) its rank,
the total number of ranks in the program, and network addresses of
other ranks.  The rank and size can be trivially passed to the process
from the process manager via environment variables.  Network addresses
could be assigned by the process manager and passed in a similar way,
but that would require the process manager to have intimate knowledge of
interconnects and the MPI implementation's internal wire-up topologies.
To achieve a separation of concerns, the PMI designers wisely suggested
that the process manager only provide a generic mechanism for MPI
processes to exchange information.

This mechanism consists of a key value store (KVS).  What one process
puts into the KVS can be read out by another process, after appropriate
synchronization.  A simple collective barrier function provides this
synchronization.  Once all processes have reached the barrier, all
data has been written, and can be read once processes are released
from the barrier.

Programs generally use PMI-1 by linking against a shared library
which includes the "standard" API functions described here.

The PMI library, on behalf of a process, MAY communicate with the process
manager using the PMI-1 wire protocol.  If that method is used, the
process manager SHOULD pass a "pre-connected" file descriptor, whose
number is communicated via an environment variable to the process.
The process then uses the wire protocol over that file descriptor to
communicate with the process manager.  In principle such a PMI library
could be independent of both process manager and program.  In practice,
most PMI libraries are provided by process managers, and use proprietary
protocols.

If the PMI_FD environment variable is set, this indicates that the PMI
wire protocol is offered, and a program MAY bypass the PMI library and
communicate directly with the process manager using the wire protocol.

== Terminology

"Process manager" is the provider of PMI services. A resource manager
MAY operate in the role of process manager.

"Process group" is a parallel program, including but not limited to
MPI programs.  It is the user of PMI services.  In this document
"program" is used interchangeably with process group.

"process" is a UNIX process, in this context, a member of a process
group or a program.

"PMI library" is a shared library that provides the PMI-1 API.

== Caveats

Some deficiencies of PMI 1.0 are noted in the PMI-2 paper[7]:

* The process manager may not share information with the program
using the PMI KVS, as no portion of its namespace was reserved for
this purpose, though PMI 1.1 does allow local process group information
to be shared in this way.
* There is no mechanism to scope a key locally for a subset of processes.
* PMI-1 is not thread safe.
* There is no way for a program to access the PMI KVS of another cooperating
program.
* There is no mechanism for respawning processes when a fault occurs.

In addition, the lack of strong guidance from the MPI Forum has limited
acceptance of the PMI wire protocol, resulted in incomplete and
non-scalable PMI implementations, and resulted in stronger coupling
between process managers and MPI implementations than necessary.

== Environment

The process manager MAY use the UNIX environment to communicate basic
process group information to processes.

If the PMI wire protocol is offered, the process manager SHALL set PMI_FD,
PMI_SIZE, and PMI_RANK to the file descriptor, size, and rank.
In addition, if the program was created by 'PMI_Spawn_multiple()',
the PMI_SPAWNED environment variable SHALL be set to (1).

A process manager SHOULD alter the LD_LIBRARY_PATH environment
variable so that programs it launches can bind at runtime with the
correct PMI library.

A process manager MAY set the PMI_LIBRARY environment variable to the
fully qualified path to its PMI library as a hint to programs that open
the PMI library using 'dlopen()'.

== Application Programming Interface

The PMI library for PMI version 1 SHALL be named "libpmi" and SHALL
have a shared library major version of 1.

All function signatures below SHALL be present in a PMI library.
Functions tagged as OPTIONAL below that are not supported by a process
manager MAY be stubbed so that they return PMI_FAIL and have no effect.

Programs SHALL NOT strongly bind to a particular process manager's
PMI library, for example with rpath, as this complicates running
a compiled program under multiple process managers.

Function signatures not described below SHALL NOT be present in a PMI
library.  There is no defined mechanism for a process manager to
extend PMI-1 without inadvertently coupling users of the extension
to the process manager.

=== Return Codes

All PMI-1 functions SHALL return one of the following integer values,
indicating the result of the operation:

* PMI_SUCCESS (0): operation completed successfully
* PMI_FAIL (-1): operation failed
* PMI_ERR_INIT (1): PMI not initialized
* PMI_ERR_NOMEM (2): input buffer not large enough
* PMI_ERR_INVALID_ARG (3): invalid argument
* PMI_ERR_INVALID_KEY (4): invalid key argument
* PMI_ERR_INVALID_KEY_LENGTH (5): invalid key length argument
* PMI_ERR_INVALID_VAL (6): invalid val argument
* PMI_ERR_INVALID_VAL_LENGTH (7): invalid val length argument
* PMI_ERR_INVALID_LENGTH (8): invalid length argument
* PMI_ERR_INVALID_NUM_ARGS (9): invalid number of arguments
* PMI_ERR_INVALID_ARGS (10): invalid args argument
* PMI_ERR_INVALID_NUM_PARSED (11): invalid num_parsed length argument
* PMI_ERR_INVALID_KEYVALP (12): invalid keyvalp argument
* PMI_ERR_INVALID_SIZE (13): invalid size argument

=== Initialization

[source,c]
----
int PMI_Init (int *spawned);
----
Initialize the PMI library for this process.  Upon success, the value
of 'spawned' (boolean) SHALL bet set to (1) if this process was created
by 'PMI_Spawn_multiple()', or (0) if not.

Errors:

* 'PMI_ERR_INVALID_ARG' - invalid argument
* 'PMI_FAIL' - initialization failed

[source,c]
----
int PMI_Initialized (int *initialized);
----
Check if the PMI library has been initialized for this process.
Upon success, the the value of 'initialized' (boolean) SHALL be set to
(1) or (0) to indicate whether or not PMI has been successfully initialized.

Errors:

* 'PMI_ERR_INVALID_ARG' - invalid argument
* 'PMI_FAIL' - unable to set the variable

[source,c]
----
int PMI_KVS_Get_name_length_max (int *length);
int PMI_KVS_Get_key_length_max (int *length);
int PMI_KVS_Get_value_length_max (int *length);
int PMI_Get_id_length_max (int *length);
----
Obtain the maximum length (including terminating NULL) of KVS name,
key, value, and id strings.  Upon success, the PMI library SHALL
set the value of 'length' to the maximum name length for the requested
parameter.

Errors:

* 'PMI_ERR_INVALID_ARG' - invalid argument
* 'PMI_FAIL' - unable to set the length

Notes:

* Process Management in MPICH[1] recommends minimum lengths for
name, key, and value of 16, 32, and 64, respectively.
* 'PMI_Get_id_length_max()' SHALL be considered an alias for
'PMI_Get_name_length_max()'.
* 'PMI_Get_id_length_max()' was dropped from pmi.h[3] on 2011-01-28 in
http://git.mpich.org/mpich.git/commit/f17423ef535f562bcacf981a9f7e379838962c6e[commit f17423ef].

[source,c]
----
int PMI_Finalize (void);
----
Finalize the PMI library for this process.

Errors:

* 'PMI_FAIL' - finalization failed

[source,c]
----
int PMI_Abort (int exit_code, const char error_msg[]);
----
Abort the process group associated with this process.
The PMI library SHALL print 'error_msg' to standard error, then exit this
process with with 'exit_code'.  This function SHALL NOT return.

=== Process Group Information

[source,c]
----
int PMI_Get_size (int *size);
----
Obtain the size of the process group to which the local process belongs.
Upon success, the value of 'size' SHALL be set to the size of the process
group.

Errors:

* 'PMI_ERR_INVALID_ARG' - invalid argument
* 'PMI_FAIL' - unable to return the size

[source,c]
----
int PMI_Get_rank (int *rank);
----
Obtain the rank (0...size-1) of the local process in the process group.
Upon success, 'rank' SHALL be set to the rank of the local process.

Errors:

* 'PMI_ERR_INVALID_ARG' - invalid argument
* 'PMI_FAIL' - unable to return the rank

[source,c]
----
int PMI_Get_universe_size (int *size);
----
Obtain the universe size, which is the the maximum future size of the
process group for dynamic applications.  Upon success, 'size' SHALL
be set to the rank of the local process.

Errors:

* 'PMI_ERR_INVALID_ARG' - invalid argument
* 'PMI_FAIL' - unable to return the size

Notes:

* See MPI-2[2] section https://www.mpi-forum.org/docs/mpi-2.0/mpi-20-html/node111.htm[5.5.1. Universe Size].

[source,c]
----
int PMI_Get_appnum (int *appnum);
----
Obtain the application number.  Upon success, 'appnum' SHALL be set to
the application number.

Errors:

* 'PMI_ERR_INVALID_ARG' - invalid argument
* 'PMI_FAIL' - unable to return the appnum

Notes

* See MPI-2[2] section https://www.mpi-forum.org/docs/mpi-2.0/mpi-20-html/node113.htm[5.5.3. MPI_APPNUM].

=== Local Process Group Information

[source,c]
----
int PMI_Get_clique_ranks (int ranks[], int length);
----
Get the ranks of the local processes in the process group.
This is a simple topology function to distinguish between processes that can
communicate through IPC mechanisms (e.g., shared memory) and other network
mechanisms.  The user SHALL set 'length' to the size returned by
'PMI_Get_clique_size()', and 'ranks' to an integer array of that length.
Upon success, the PMI library SHALL fill each slot of the array with the
rank of a local process in the process group.

Errors:

* 'PMI_ERR_INVALID_ARG' - invalid argument
* 'PMI_ERR_INVALID_LENGTH' - invalid length argument
* 'PMI_FAIL' - unable to return the ranks

Notes:

* This function returns the ranks of the processes on the local node.
* The array must be at least as large as the size returned by
'PMI_Get_clique_size()'.
* This function was dropped from pmi.h[3] on 2011-01-28 in
http://git.mpich.org/mpich.git/commit/f17423ef535f562bcacf981a9f7e379838962c6e[commit f17423ef]
* In PMI 1.1 implementations, this information MAY be retrieved from the KVS
as described under "PMI 1.1 KVS Schema".

[source,c]
----
int PMI_Get_clique_size (int *size);
----
Obtain the number of processes on the local node.  Upon success, 'size'
SHALL be set to the number of processes on the local node.

Errors:

* 'PMI_ERR_INVALID_ARG' - invalid argument
* 'PMI_FAIL' - unable to return the clique size

Notes:

* This function was dropped from pmi.h[3] on 2011-01-28 in
http://git.mpich.org/mpich.git/commit/f17423ef535f562bcacf981a9f7e379838962c6e[commit f17423ef]
* In PMI 1.1 implementations, this information MAY be retrieved from the KVS
as described under "PMI 1.1 KVS Schema".

=== Key Value Store

[source,c]
----
int PMI_KVS_Put (const char kvsname[], const char key[], const char value[]);
----
Put a key/value pair in a keyval space.
The user SHALL set 'kvsname' to the name returned from 'PMI_KVS_Get_my_name()'.
The user SHALL set 'key' and 'value' to NULL terminated strings no longer
(with NULL) than the sizes returned by 'PMI_KVS_Get_key_length_max()' and
'PMI_KVS_Get_value_length_max()' respectively.

Upon success, the PMI value SHALL be visible to other processes after
'PMI_KVS_Commit()' and 'PMI_Barrier()' are called.

Errors:

* 'PMI_ERR_INVALID_KVS' - invalid kvsname argument
* 'PMI_ERR_INVALID_KEY' - invalid key argument
* 'PMI_ERR_INVALID_VAL' - invalid val argument
* 'PMI_FAIL' - put failed

Notes:

* The function MAY complete locally.
* All keys put to a keyval space SHALL be unique to the keyval space.
* A key SHALL NOT be put more than once to a keyval space.

[source,c]
----
int PMI_KVS_Commit (const char kvsname[]);
----
Commit all previous puts to the keyval space.  Upon success, all puts
since the last 'PMI_KVS_Commit()' shall be stored into the specified
'kvsname'.

Errors:

* PMI_ERR_INVALID_ARG - invalid argument
* PMI_FAIL - commit failed

Notes:

* This function commits all previous puts since the last 'PMI_KVS_Commit()'
into the specified keyval space.
* It is a process local operation, thus in some implementations,
it MAY have no effect and still return PMI_SUCCESS.

[source,c]
----
int PMI_KVS_Get (const char kvsname[], const char key[], char value[], int length);
----
Get a key/value pair from a keyval space.
The user SHALL set 'kvsname' to the name returned from 'PMI_KVS_Get_my_name()'.
The user SHALL set 'length' to the length of the 'value' array, which SHALL
be no shorter than the length returned by 'PMI_KVS_Get_value_length_max()'.
The user SHALL set 'key' to a NULL terminated string no longer (with NULL)
than the size returned by 'PMI_KVS_Get_key_length_max()'.

Upon success, the PMI library SHALL fill 'value' with the value of 'key'.

Errors:

* 'PMI_ERR_INVALID_KVS' - invalid kvsname argument
* 'PMI_ERR_INVALID_KEY' - invalid key argument
* 'PMI_ERR_INVALID_VAL' - invalid val argument
* 'PMI_ERR_INVALID_LENGTH' - invalid length argument
* 'PMI_FAIL' - get failed

[source,c]
----
int PMI_KVS_Get_my_name (char kvsname[], int length);
int PMI_Get_kvs_domain_id (char kvsname[], int length);
int PMI_Get_id( char kvsname[], int length );
----
This function returns the common keyval space for this process group.
The user SHALL set set 'length' to the length of the 'kvsname' array,
which SHALL be no shorter than the length returned by
'PMI_KVS_Get_name_length_max()'.

Upon success, the PMI library SHALL set 'kvsname' to a NULL terminated
string representing the keyval space.

Errors:

* 'PMI_ERR_INVALID_ARG' - invalid argument
* 'PMI_ERR_INVALID_LENGTH' - invalid length argument
* 'PMI_FAIL' - unable to return the kvsname

Notes:

* length SHALL be greater than or equal to the length returned
by 'PMI_KVS_Get_name_length_max()'.
* 'PMI_Get_kvs_domain_id()' and 'PMI_Get_id()' SHALL be considered
an alias for 'PMI_KVS_Get_my_name()'.
* 'PMI_Get_kvs_domain_id()' and 'PMI_Get_id()' were dropped from pmi.h[3]
on 2011-01-28 in http://git.mpich.org/mpich.git/commit/f17423ef535f562bcacf981a9f7e379838962c6e[commit f17423ef].

[source,c]
----
int PMI_Barrier (void);
----
This function is a collective call across all processes in the process group
the local process belongs to.  The PMI library SHALL attempt to block until
all processes in the process group have entered the barrier call, or an
error occurs.

Errors:

* PMI_FAIL - barrier failed

Notes:

* This operation is the only collective defined for PMI-1.
* Some implementations MAY piggyback a KVS data exchange on the barrier
operation internally.
* The barrier operation MUST be usable as a generic synchronization mechanism,
without requiring KVS data to be queued for exchange.

[source,c]
----
int PMI_KVS_Create( char kvsname[], int length );
int PMI_KVS_Destroy( const char kvsname[] );
int PMI_KVS_Iter_first(const char kvsname[], char key[], int key_len, char val[], int val_len);
int PMI_KVS_Iter_next(const char kvsname[], char key[], int key_len, char val[], int val_len);
----

Notes:

* These functions are OPTIONAL.
* Dropped from pmi.h[3] on 2011-01-28 in
http://git.mpich.org/mpich.git/commit/f17423ef535f562bcacf981a9f7e379838962c6e[commit f17423ef],

=== Dynamic Process Management

[source,c]
----
typedef struct {
    const char * key;
    char * val;
} PMI_keyval_t;

int PMI_Spawn_multiple (int count,
                        const char * cmds[],
                        const char ** argvs[],
                        const int maxprocs[],
                        const int info_keyval_sizesp[],
                        const PMI_keyval_t * info_keyval_vectors[],
                        int preput_keyval_size,
                        const PMI_keyval_t preput_keyval_vector[],
                        int errors[]);
----
This function spawns a set of processes into a new process group.
'count' refers to the size of the array parameters 'cmd', 'argvs',
'maxprocs', 'info_keyval_sizes' and 'info_keyval_vectors'.
'preput_keyval_size' refers to the size of the 'preput_keyval_vector' array.

'preput_keyval_vector' contains keyval pairs that will be put in the
keyval space of the newly created process group before the processes
are started.

The 'maxprocs' array specifies the desired number of processes
to create for each 'cmd' string.  The actual number of processes
may be less than the numbers specified in maxprocs.  The acceptable
number of processes spawned may be controlled by ``soft'' keyvals in
the info arrays.

Environment variables may be passed to the spawned processes through PMI
implementation specific 'info_keyval' parameters.

Errors:

* PMI_ERR_INVALID_ARG - invalid argument
* PMI_FAIL - spawn failed

Notes:

* This function is OPTIONAL in process managers that do not support
dynamic process management.
* The ``soft'' option is specified by mpiexec in the MPI-2 standard.
* See MPI-2[2] section https://www.mpi-forum.org/docs/mpi-2.0/mpi-20-html/node98.htm[5.3.5.1. Manager-worker Example, Using MPI_SPAWN.]

[source,c]
----
int PMI_Publish_name (const char service_name[], const char port[]);
int PMI_Unpublish_name (const char service_name[]);
int PMI_Lookup_name (const char service_name[], char port[]);
----
Publish/unpublish/lookup a name.

Errors:

* PMI_ERR_INVALID_ARG - invalid argument
* PMI_FAIL - unable to publish service

Notes:

* These functions are OPTIONAL in process managers that do not support
dynamic process management.
* See MPI-2[2] section https://www.mpi-forum.org/docs/mpi-2.0/mpi-20-html/node104.htm[5.4.4. Name Publishing].

[source,c]
----
int PMI_Parse_option (int num_args, char *args[], int *num_parsed, PMI_keyval_t **keyvalp, int *size);
int PMI_Args_to_keyval (int *argcp, char *((*argvp)[]), PMI_keyval_t **keyvalp, int *size);
int PMI_Free_keyvals (PMI_keyval_t keyvalp[], int size);
int PMI_Get_options (char *str, int *length);
----

Notes:

* These functions are OPTIONAL.
* These functions were dropped from pmi.h[3] on 2009-05-01 in
http://git.mpich.org/mpich.git/commit/52c462d2be6a8d0720788d36e1e096e991dcff38[commit 52c462d]

== PMI 1.1 KVS Schema

In PMI 1.1, the process manager SHALL store the local process group information
in the KVS under the "PMI_process_mapping" key.

TBD

See https://github.com/flux-framework/flux-core/issues/665[flux-framework/flux-core#665]

== PMI 1.1 Wire Protocol

The PMI-1 wire protocol was deduced from the MPICH simple PMI
implementation[4] used by the Hydra process manager.

=== Initialization

----
C: cmd=init pmi_version=1 pmi_subversion=1\n
S: cmd=response_to_init rc=0 pmi_version=1 pmi_subversion=1\n
C: cmd=get_maxes\n
S: cmd=maxes rc=0 kvsname_max=256 keylen_max=256 vallen_max=256\n
----

----
C: cmd=abort exitcode=<integer>\n
S: \n
----

----
C: cmd=finalize\n
S: cmd=finalize_ack rc=0\n
----

=== Process Group Information

----
C: cmd=get_universe_size\n
S: cmd=universe_size rc=0 size=<integer>\n
----

----
C: cmd=get_appnum\n
S: cmd=appnum rc=0 appnum=<integer>\n
----

=== Key Value Store

----
C: cmd=put kvsname=<string> key=<string> value=<string>\n
S: cmd=put_result rc=1\n
----

----
C: cmd=get_my_kvsname\n
S: cmd=my_kvsname rc=0 kvsname=<string>\n
----

----
C: cmd=barrier_in\n
S: cmd=barrier_out rc=0\n
----

----
C: cmd=get kvsname=<string> key=<string>\n
S: cmd=get_result rc=0 value=<string>\n
----

=== Dynamic Process Management

FIXME: This section needs testing and verification.

----
C: mcmd=spawn\n
C: nprocs=<integer>\n
C: execname=<string>\n
C: totspawns=<integer>\n
C: spawnssofar=<integer>\n
C: arg0=<string>\n
C: arg1=<string>\n
C: ...
C: argcnt=<integer>\n

C: preput_num=<integer>\n
C: preput_key_0=<string>\n
C: preput_val_0=<string>\n
C: preput_key_1=<string>\n
C: preput_val_1=<string>\n
C: ...

C: info_num=<integer>\n
C: info_key_0=<string>\n
C: info_val_0=<string>\n
C: info_key_1=<string>\n
C: info_val_1=<string>\n
C: ...
C: endcmd\n

S: cmd=spawn_result rc=0 errcodes 0,0,0,...\n
----

----
C: cmd=publish_name service=<string> port=<string>\n
S: cmd=publish_result rc=0 info=ok\n
----

----
C: cmd=unpublish_name service=<string>\n
S: cmd=unpublish_result rc=0 info=ok\n
----

----
C: cmd=lookup_name service=<string>\n
S: cmd=lookup_result rc=0 info=ok port=<string>\n
----

== MPI Quirks

Process managers SHOULD take into account the following requirements
specific to popular MPI implementations.

=== MPICH

If configured without specifying any PMI options, MPICH attempts to use
the PMI-1 simple wire protocol.

=== MVAPICH

MVAPICH, a derivative of MPICH, requires the following environment variables
to be set to enable PMI:

* MPIRUN_NTASKS - set to the process group size
* MPIRUN_RANK - set to the process rank
* MPIRUN_RSH_LAUNCH - set to 1

=== Intel MPI

Intel MPI[6], a derivative of MPICH, requires the following environment
variable to be set to enable PMI

* I_PMI_MPI_LIBRARY - set to path of PMI library

=== OpenMPI

TBD

== References

* [1] https://drive.google.com/file/d/0B273EWJxZUxsbS15SEkzZGtXU2c/view?usp=sharing[Process Management in MPICH Draft 2.1]
* [2] https://www.mpi-forum.org/docs/mpi-2.0/mpi-20-html/mpi2-report.html[MPI-2: Extensions to the Message-Passing Interface]
* [3] http://git.mpich.org/mpich.git/blob/HEAD:/src/include/pmi.h[MPICH canonical pmi.h header]
* [4] http://git.mpich.org/mpich.git/tree/HEAD:/src/pmi/simple[MPICH simple PMI implementation]
* [5] https://github.com/SchedMD/slurm/blob/master/src/api/pmi.c[SLURM PMI-1 implementation]
* [6] https://software.intel.com/en-us/articles/how-to-use-slurm-pmi-with-the-intel-mpi-library-for-linux[Intel Developer Zone: How to use SLURM PMI with the Intel MPI Library for Linux?]
* [7] http://www.mcs.anl.gov/papers/P1760.pdf[PMI: A Scalable Parallel Process-Management Interface for Extreme-Scale Systems], P. Balaji et al, EuroMPI Proceedings, 2010.
