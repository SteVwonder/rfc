
19/Flux Locally Unique ID (FLUID)
=================================

This specification describes a scheme for a distributed, uncoordinated
*flux locally unique ID* service that generates 64 bit k-ordered, unique
identifiers that are a combination of timestamp since some epoch,
generator id, and sequence number. The scheme is used to generate
Flux job IDs.

-  Name: github.com/flux-framework/rfc/spec_19.rst

-  Editor: Mark Grondona <mgrondona@llnl.gov>

-  State: raw


Language
--------

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to
be interpreted as described in `RFC 2119 <http://tools.ietf.org/html/rfc2119>`__.


Background
----------


Criteria
~~~~~~~~

*Very low probability of collision:* Like 128 bit UUIDs on a global scale,
FLUIDs should provide a reasonable guarantee against collisions on a
smaller scale: within a Flux instance.

*Distributed:* Flux job ingest should be distributed to achieve a high
job ingest rate, therefore the generation of ID’s should also be capable
of being distributed to promote scalability.

*Loosely ordered:* Job ID’s generated by legacy resource managers are
typically monotonically increasing integers that reflect job submission
order. This property is of debatable utility, but following the principle
of least astonishment, FLUIDs should retain it if possible.


Existing Solutions
~~~~~~~~~~~~~~~~~~

The design of FLUIDs is patterned after
`Twitter Snowflake <https://blog.twitter.com/2010/announcing-snowflake>`__, and
the derived implementation `Boundary Flake <https://github.com/boundary/flake>`__.
The basic scheme is to couple a timestamp, machine or generator id, and
sequence number into a number of bits.

Placing the timestamp into the most significant bits of the ID allows
independently generated IDs to be loosely sorted (k-ordered). Use of a
separate machine ID per generator ensures uniqueness without coordination,
and the sequence number ensures each generator can create a certain number
of IDs per timestamp unit.


Implementation
--------------

FLUIDs are composed of ``[ timestamp | id | sequence ]`` similar to Snowflake,
to allow distributed, uncoordinated ID generation across a Flux instance,
with the allocation of bits customized for the unique use case in Flux:

-  40 bits for timestamp since epoch in milliseconds, good for a 35 year
   long runtime with custom epoch set to job start time.

-  14 bits for generator ID (up to 16K generators). By default, the generator
   ID could be set to the rank. For sessions greater than 16K ranks, some
   generators could be idled and forward requests up the tree to keep the max
   generators to 16K.

-  10 bits for sequence number (1024 IDs per ms)

With this scheme it is theoretically possible to create a max of about 16B
FLUIDs per second for 34 years.

This type of generator *guarantees* unique IDs, with probability of collision
equal to zero, so no collision detection is required.


Representation
~~~~~~~~~~~~~~

A FLUID is a 64-bit integer, e.g. ``4208082371413712``.

Encoding as a 16-character hexadecimal string is a fairly compact string
representation, e.g. the above example encodes to ``"749de79000800"``.

Schemes like `mnemonicode <https://github.com/singpolyma/mnemonicode>`__ can
convert integers to strings of pronounceable words and back again, e.g. the
above example encodes to ``"memo-felix-virus—​warning-france-academy"``.
A larger dictionary decreases the number of words required.
